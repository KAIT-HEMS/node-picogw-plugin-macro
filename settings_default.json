{
	"OnDemand": {
		"code": "/*\nThe macro script is basically a sandboxed JavaScript code, with some additional methods/variables:\n\n + resolve([Return value])/reject([Return value]): Returns JSON object by 'GET /v1/macro/run' call\n + addLog(key,value): add log entry to the internal DB, accessed by GET /v1/macro/log\n + getArgs(): Returns a JSON object that represents GET argument of /v1/macro/run call.\n + print([args]): Shows string on console.\n + callProc({method:'GET'|'PUT'|..., path: 'Path string' [, args:{[JSON object]} ] [,timeout: number] }): Calls other APIs of this gateway.\n + wait(milliseconds) : async function to wait\n + global: A JSON object that is consistent within calls. Reset on reboot. If you need a persistent storage even over multiple boots, use db plugin through callProc() method.\n\nSome examples are shown below.\n*/\n\n\n///========================\n// getArgs() receives GET argument of the call.\n// Eg. /v1/macro/run?a=b&c=d        will make        getArgs() to return {a:'b',c:'d'}\n\nprint( 'GET arguments: '+JSON.stringify(getArgs()) );  // print() amounts to console.log()\n\n\n\n\n///========================\n// global is a JSON object that is consistent within calls. Reset on reboot.\n\nif( global.count == null ) global.count  = 0; // Initialization\nprint('global.count = '+ ++global.count );  // increments on each call.\n\n\n\n\n///========================\n// Handling persistent data across multiple boots (in addition to calls) with the help\n// of db plugin: (This example shows the number of calls. (Updated at each call) \n\nconst KEYNAME = 'runScriptCallCount' ;\n\n// Load data from DB plugin\nlet dbVal = await callProc({method:'GET',path:'/v1/db/'+KEYNAME});\n// If no data is stored yet, set the value as 0. otherwise, increment.\nlet curVal = (dbVal.value || 0)+1 ;\n\n// Wait for 100 milliseconds\nawait wait(100);\n\n// Save new data\nawait callProc({method:'POST' ,path:`/v1/db/${KEYNAME }` ,args:{value:curVal} });\nprint( `/v1/db/${KEYNAME } = ${curVal}` );        // Prints the call count to the command line\n\n\n\n\n///========================\n// Check powers of ECHONET Lite devices\nconst CHECK_DEVS = ['AirConditioner','GenericIllumination'] ;\n// Use regular expression to check multiple devices at once\nconst CHECK_PATH = '/v1/echonet/(' + CHECK_DEVS.join('|') + ')_.+/operatingstate' ;\nre = await callProc({method:'GET',path:CHECK_PATH}).catch(reject);\n\n// addLog(`Call ${countVal}`, re);  // Append to log data within macro plugin, which can be accessed by /v1/macro/log\n\nfor( const path in re ){\n  if( re[path].value == 'on' ){\n    // You can return a value from the macro by calling resolve({...}) or reject({...}).\n\n    resolve('on'); // returns 'on' mode if at least one device is on.\n    return ;\n  }\n}\n\nresolve('off'); // Otherwise (Everything is off) the mode is 'off'"
	},
	"Periodical": {
		"code": "/*\nThe polling script is basically a sandboxed JavaScript code, with some additional methods/variables:\n\n + addLog(key,value): add log entry to the internal DB, accessed by GET /v1/macro/log\n + print([args]): Shows string on console.\n + callProc({method:'GET'|'PUT'|..., path: 'Path string' [, args:{[JSON object]} ] [,timeout: number] }): Calls other APIs of this gateway.\n + wait(milliseconds) : async function to wait\n + global: A JSON object that is consistent within calls. Reset on reboot.\n\n!! Note polling function does not have resolve(), reject(), getArgs() functions\n\nSome examples are shown below.\n*/\n\nprint('Poling in macro plugin');\n\n// Check whole mode\nlet re = await callProc({method:'GET',path:'/v1/macro/run'}).catch(e=>{});\naddLog('macro execution result',re.value);\n\n// Wait for 100 milliseconds\nawait wait(100);\n\n// Check server status\nre = await callProc({method:'GET',path:'/v1/admin/server_status/'}).catch(e=>{});\naddLog('server status',JSON.stringify(re.result));\n",
		"pollInterval": "-1",
		"pollLogEntryMax": 300
	}
}